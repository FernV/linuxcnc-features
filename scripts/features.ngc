( Mill defaults )

G17 (xy plane)
G20 (inches)
G40 (cancel cutter radius compensation)
G49 (cancel tool length offset)
G90 (absolute distance mode)
G92.1 (cancel G92 offsets)
G94 (units/min feedrate)
G54 (Coordinate system 1 by default)
G64 p0.001 (path control stop)

#<_z_clear> = 0.2

#<_surface> = 0
#<_depth> = -0.5
#<_depth_step> = -0.2

#<_ffeed> = 10
#<_final_feed> = 6
#<_vertical_feed> = 2

#<_spindle_rpm> = 1000
#<_final_spindle_rpm> = 1000

#<_plunge_down> = 0
#<_plunge_ratio> = 0.07
#<_pocket_ratio> = 0.9
#<_pocket_cutting> = 0.85

#<_probe_feed> = 15
#<_probe_latch> = -0.1
#<_probe_latch_feed> = 1
#<_probe_func> = 38.2
#<_probe_tip_dia> = 0.125
#<_probe_depth> = 1

#<_tool_probe_set> = 0

#<_drill_mode> = 73
#<_drill_feed> = 1
#<_drill_retract>= 0.175
#<_drill_dwell> = 3
#<_drill_q> = 0.3

#<_show_final_cuts> = 1
#<_show_bottom_cut> = 1

#<_units_factor> = 1
#<_units_r> = 1  (radius and diameter)
#<_units_w> = 1  (width, height, length)
#<_units_d> = 1  (depth)

(This is a safety message to help avoid gouging in the work piece)
(Disable messages at will but let the loop in case you forget)
/ (debug, Message from defaults.ngc : Stop and check 'Skip lines starting with /')
/ (print, Message from defaults.ngc : Stop and check 'Skip lines starting with /')
/ (AXIS,notify, Message from defaults.ngc : Stop and check 'Skip lines starting with /')
/ G0 Z3
/ o<safety-999> repeat [100]
/	G0 X-2 Y-2
/	G0 Y2
/	G0 X2
/	G0 Y-2
/ o<safety-999> endrepeat 

F#<_ffeed>
S#<_spindle_rpm>    
        
( end mill defaults )

(Definitions)


;call x y z opt w h d
o<fv_design-cube> sub
	o<design-cube-if-00> if [#4]
		#<x> = [#1 - #5 / 2]
		#<y> = [#2 - #6 / 2]
	o<design-cube-if-00> else
		#<x> = #1
		#<y> = #2
	o<design-cube-if-00> endif		

	G0 X#<x> Y#<y> Z[#3]
	G1 X[#<x> + #5]
	G1 Y[#<y> + #6]
	G1 X#<x>
	G1 X#<x> Y#<y>
	G1 Z[#3 + #7]
	G1 X[#<x> + #5]
	G0 Z[#3]
	G1 Z[#3 + #7]
	G1 Y[#<y> + #6]
	G0 Z[#3]
	G1 Z[#3 + #7]
	G1 X#<x>
	G0 Z[#3]
	G1 Z[#3 + #7]
	G1 X#<x> Y#<y>	
o<fv_design-cube> endsub




(return: _line:len,phi,cos,sin)

o<line> sub
	(not_a_subfile)
	#<x1> = #1
	#<y1> = #2
	#<x2> = #3
	#<y2> = #4
	;(print line: x1=#<x1> y1=#<y1> x2=#<x2> y2=#<y2>)

	#<epsilon>   = 0.000001
	#<_line:dely>      = [#<y1> - #<y2>]
	#<_line:delx>      = [#<x1> - #<x2>]
	#<_line:len> = SQRT[#<_line:delx> * #<_line:delx> + #<_line:dely> * #<_line:dely>]

	o<l01> if [ABS[#<_line:delx>] GT #<epsilon>]
		 #<_line:phi> = ATAN[#<_line:dely>] / [#<_line:delx>]
	o<l01> else
		o<l02> if [#<_line:dely> GE 0]
			#<_line:phi> =  90
		o<l02> else
			#<_line:phi> = -90
		o<l02> endif
	o<l01> endif

	#<_line:cos> = COS[#<_line:phi>]
	#<_line:sin> = SIN[#<_line:phi>]

	;(print line: len=#<_line:len> angle=#<_line:phi> cos=#<_line:cos> sin=#<_line:sin>)
o<line> endsub

(Rotate-xy sub definition)
(#<_rotate_result_x> = 0)
(#<_rotate_result_y> = 0)
o<rotate-xy> SUB
	#<x> = #1
	#<y> = #2
	#<cx> = #3
	#<cy> = #4
	#<a> = #5
	#<_rotate_result_x> = [[#<x> - #<cx>] * COS[#<a>] - [#<y> - #<cy>] * SIN[#<a>] + #<cx>]
	#<_rotate_result_y> = [[#<x> - #<cx>] * SIN[#<a>] + [#<y> - #<cy>] * COS[#<a>] + #<cy>]
o<rotate-xy> ENDSUB



(This subroutine limits the amount of dive into workpiece to the ratio defined by _plunge_ratio and does the cut)
(CALL to_x, to_y, len, dir, i, j)
o<fv_cut-to> sub
	o<cut-00> if [#<_cut_to:seg_z> GT #<_cut_to:loop_end_z>]
		o<cut-02> if [#3 GT 0]
			#<_cut_to:seg_z> = [#<_cut_to:seg_z> - #3 * #<_plunge_ratio>]
			o<cut-02a> if [#<_cut_to:seg_z> LT #<_cut_to:loop_end_z>]
				#<_cut_to:seg_z> = #<_cut_to:loop_end_z>
			o<cut-02a> endif
		o<cut-02> endif
	o<cut-00> endif
	
	o<cut-10> if [[#4 EQ 2] OR [#4 EQ 3]]
		G#4 X#1 Y#2 Z#<_cut_to:seg_z> I#5 J#6
	o<cut-10> else
		G1 X#1 Y#2 Z#<_cut_to:seg_z>
	o<cut-10> endif	
o<fv_cut-to> endsub

(compute a quarter-arc preentry and radius vector to a point x,y)
(return: _entry:prex,prey == preentry point)
(        _entry:vx,vy     == vector from start x,y to center xctr,yctr)

(Usage: for entry to a point on an arc)
( o<entry> call [x][y][xctr][yctr][dir][option][cut_start])
( will set compensation and bring cutter to x, y then z ready to start cutting)

o<fv_entry-arc> sub
	#<_entry:x> = #1
	#<_entry:y> = #2
	#<xctr>     = #3
	#<yctr>     = #4
	#<dir>      = #5 (2:cw, 3:ccw)
	#<opt>      = #6 (Inside=0:Outside=1:On the line=2:Create a pocket=3)

	G0 Z#<_z_clear>
	G40

	o<comp00> if [#<opt> EQ 2] (no compensation)
		     G0 X#<_entry:x> Y#<_entry:y>
	o<comp00> else
	
		o<opt_00> if [#<opt> EQ 3] (pocket is inside)
			#<opt> = 0
		o<opt_00> endif	

		o<line> CALL [#<_entry:x>] [#<_entry:y>] [#<xctr>] [#<yctr>]
		#<rt> = [[#5410 + 0.001] / 2] (tool radius used to calc pre-entry point)
		
		(compute pre-entry px,py for 1/4 circle with radius rt)
		(and vector from start x,y to center of circle)
		o<l60> if [#<opt> EQ 0] (inside)
			o<l70>   if [#<dir> EQ 2]  (cw)
					   #<px> = [#<_line:delx> - #<rt> * #<_line:sin> - #<rt> * #<_line:cos>]
					   #<py> = [#<_line:dely> + #<rt> * #<_line:cos> - #<rt> * #<_line:sin>]
					   #<vx> = [0 + #<rt> * #<_line:sin>]
					   #<vy> = [0 - #<rt> * #<_line:cos>]
			o<l70>   else  (ccw)
					   #<px> = [#<_line:delx> + #<rt> * #<_line:sin> - #<rt> * #<_line:cos>]
					   #<py> = [#<_line:dely> - #<rt> * #<_line:cos> - #<rt> * #<_line:sin>]
					   #<vx> = [0 - #<rt> * #<_line:sin>]
					   #<vy> = [0 + #<rt> * #<_line:cos>]
			o<l70>   endif
		o<l60> else
			o<l80>   if [#<dir> EQ 2] (cw)
					   #<px> = [#<_line:delx> - #<rt> * #<_line:sin> + #<rt> * #<_line:cos>]
					   #<py> = [#<_line:dely> + #<rt> * #<_line:cos> + #<rt> * #<_line:sin>]
					   #<vx> = [0 + #<rt> * #<_line:sin>]
					   #<vy> = [0 - #<rt> * #<_line:cos>]
			o<l80>   else (ccw)
					   #<px> = [#<_line:delx> + #<rt> * #<_line:sin> + #<rt> * #<_line:cos>]
					   #<py> = [#<_line:dely> - #<rt> * #<_line:cos> + #<rt> * #<_line:sin>]
					   #<vx> = [0 - #<rt> * #<_line:sin>]
					   #<vy> = [0 + #<rt> * #<_line:cos>]
			o<l80>   endif
		o<l60> endif

		#<_entry:prex> = [#<px> + #<xctr>]
		#<_entry:prey> = [#<py> + #<yctr>]
		#<_entry:vx>   = #<vx>
		#<_entry:vy>   = #<vy>

		G0 X#<_entry:prex> Y#<_entry:prey>
				     
		o<l10> if [#<opt> EQ 0] (inside)
			o<l20> if [#<dir> EQ 2] (cw)
				G42 (cutter radius comp right of path)
				G2  x#<_entry:x> y#<_entry:y> i#<_entry:vx> j#<_entry:vy>
			o<l20> else (ccw)
				G41 (cutter radius comp left of path)
				G3  x#<_entry:x> y#<_entry:y> i#<_entry:vx> j#<_entry:vy>
			o<l20> endif
		o<l10> else (outside)
			o<l30> if [#<dir> EQ 2] (2 ==> cw)
				G41 (cutter radius comp left of path)
				G3  x#<_entry:x> y#<_entry:y> i#<_entry:vx> j#<_entry:vy>
			o<l30> else (3 ==> ccw)
				G42 (cutter radius comp right of path)
				G2  x#<_entry:x> y#<_entry:y> i#<_entry:vx> j#<_entry:vy>
			o<l30> endif
		o<l10> endif		
	o<comp00> endif
	
	G0 Z[#7 + 0.01] (hardcoded delta)
	G1 Z#7 (plunge)
	#<_entry:done> = 1
	
o<fv_entry-arc> endsub


(info: fv_circle: modified helix, in/out/pocket, cw/ccw, D-shape)
o<fv_circle> sub (CALL [#<delx>] [#<delx>] [#<diam>] [#flat] [#rot] [#cut_opt] [#dir] [#cut_start] [#depth] [#show_final])

	(Assign significative names to params passed)
	#<final_cx>   =  #1 (x center)
	#<final_cy>   =  #2 (y center)
	#<final_rad>  =  [#3 / 2] (diameter / 2)
	#<final_flat> =  #4 (d flat)
	#<rot>        =  #5 (flat angle)
	#<cut_opt>    =  #6 (Inside=0:Outside=1:On the line=2:Create a pocket=3)
	#<dir>	      =  #7 (Clockwise=2:Counter-Clockwise=3)
	#<cut_start>  =  #8
	#<cut_depth>  =  #9
	#<show_final> = #10

	(Check validity of params passed)
	o<l00> if [#<final_rad> EQ 0]
			   (debug, circle: bad diameter #<dia> - EXITING)
			   (print, circle: bad diameter #<dia> - EXITING)
			   (AXIS,notify, circle: diameter #<dia> - EXITING)
			   M2
	o<l00> endif

	o<l02> if [#<cut_depth> EQ 0.0]
			   (debug, circle: bad cut_depth #<cut_depth> - EXITING)
			   (print, circle: bad cut_depth #<cut_depth> - EXITING)
			   (AXIS,notify, circle: bad cut_depth - EXITING)
			   M2
	o<l02> else if [#<cut_depth> GT 0.0]
			 	#<cut_depth> = [0 - #<cut_depth>]           
	o<l02> endif
	(end validity check)
	
	o<pocket> if [[#<cut_opt> EQ 3] AND [#5410 GT 0] AND [#<final_rad> GT #5410]] (...a pocket and tool dia > 0)
		o<has-flat-0> if [#<final_flat> GT 0]
			#<cycle_count> = FUP[#<final_rad> / #5410 * 2 / #<_pocket_ratio>]
		o<has-flat-0> else
			#<cycle_count> = FUP[#<final_rad> / #5410 / #<_pocket_ratio>]
		o<has-flat-0> endif
		#<min_rad> = [#<_pocket_ratio> * #5410]
	o<pocket> else
		#<cycle_count> = 1
	o<pocket> endif
	
	#<cycle> = 0		
	o<wh_cycle> while [#<cycle> LT #<cycle_count>]
	
		o<wh_cycle-0> if [#<cycle> EQ #<cycle_count> - 1]
			#<radius> = #<final_rad>
			#<flat> = #<final_flat>
			#<cx> = #<final_cx>
			#<cy> = #<final_cy>
		o<wh_cycle-0> else
			#<radius> = [#<min_rad> + [#<final_rad> - #<min_rad>] * #<cycle> / [#<cycle_count> - 1]]
			o<has-flat> if [#<final_flat> GT 0]		
				#<cx> = [#<final_cx> - #<final_rad> + #<radius>]
				o<rotate-xy> CALL [#<cx>] [#<final_cy>] [#<final_cx>] [#<final_cy>] [#<rot>]
					#<cx> = #<_rotate_result_x>
					#<cy> = #<_rotate_result_y>
				#<flat> = [[#<radius> - #<final_rad>] * 2 + #<final_flat>]
				o<has-flat-2> if [#<flat> LT 0]
					#<flat> = 0
				o<has-flat-2> endif
			o<has-flat> else
				#<cx> = #<final_cx>
				#<cy> = #<final_cy>
				#<flat> = #<final_flat>
			o<has-flat> endif
		o<wh_cycle-0> endif	 
		
		#<cycle> = [#<cycle> + 1]

	 	(to avoid gouging, start point is arc opposite flat)
	 	(start point x0,y0 and vector to center vx0,vy0)
	 	#<x1>  = [#<cx> + #<radius> * cos[#<rot> + 180]]
	 	#<y1>  = [#<cy> + #<radius> * sin[#<rot> + 180]]
	 	#<vx12> =        [#<radius> * cos[#<rot>]]
	 	#<vy12> =        [#<radius> * sin[#<rot>]]
	 	
	 	#<d2>  =  ACOS[[#<radius> - #<flat>] / #<radius>]
		(points at the ends of the arc)
		(x1,y1 start point of flat, vx1,vy1 vector to center)
		(x2,y2 start point of flat, vx2,vy2 vector to center)
		o<l08> if [#<dir> EQ 2] (cw)
			#<x2>  = [#<cx> + #<radius> * cos[#<rot> + #<d2>]]
			#<y2>  = [#<cy> + #<radius> * sin[#<rot> + #<d2>]]

			#<x3>  = [#<cx> + #<radius> * cos[#<rot> - #<d2>]]
			#<y3>  = [#<cy> + #<radius> * sin[#<rot> - #<d2>]]
			#<vx31> =        [#<radius> * cos[#<rot> - #<d2> + 180]]
			#<vy31> =        [#<radius> * sin[#<rot> - #<d2> + 180]]
		o<l08> else
			#<x2>  = [#<cx> + #<radius> * cos[#<rot> - #<d2>]]
			#<y2>  = [#<cy> + #<radius> * sin[#<rot> - #<d2>]]

			#<x3>  = [#<cx> + #<radius> * cos[#<rot> + #<d2>]]
			#<y3>  = [#<cy> + #<radius> * sin[#<rot> + #<d2>]]
			#<vx31> =        [#<radius> * cos[#<rot> + #<d2> + 180]]
			#<vy31> =        [#<radius> * sin[#<rot> + #<d2> + 180]]
		o<l08> endif

		o<len_calc> if [#<cut_opt> EQ 1] (outside)
			#<len_arc> = [[#<radius> + #5410 / 2] * 3.141592 * [180 - #<d2>] / 180]
		o<len_calc> elseif [#<cut_opt> EQ 2] (on line)
			#<len_arc> = [#<radius> * 3.141592 * [180 - #<d2>] / 180]
		o<len_calc> else ( Inside or a pocket )
			#<len_arc> = [[#<radius> - #5410 / 2] * 3.141592 * [180 - #<d2>] / 180]
		o<len_calc> endif

		(this is not exactly right for in or out but should never cause a problem)
		#<len_cord> = [#<radius> * SIN[#<d2>] * 2]
		
		#<final_loop> = 1
		o<will_show_final> if [#<cycle> EQ #<cycle_count>]
			/ #<show_final> = [#10 + 10]
		o<will_show_final> else
			#<show_final> = 0
		o<will_show_final> endif
		
		F#<_ffeed>
		S#<_spindle_rpm>
		#<_cut_to:seg_z> = #<cut_start>
				
		o<fv_entry-arc> call [#<x1>] [#<y1>] [#<cx>] [#<cy>] [#<dir>] [#<cut_opt>] [#<cut_start>]		

		o<wh010> while [[#<_cut_to:seg_z> GT #<cut_depth>] OR #<final_loop> OR #<show_final>]
		
			o<wh010-final> if [#<_cut_to:seg_z> GT #<cut_depth>]
				#<_cut_to:loop_end_z> = [#<_cut_to:seg_z> + #<_depth_step>]
				o<wh-if1> if [#<_cut_to:loop_end_z> LT #<cut_depth>]
					#<_cut_to:loop_end_z> = #<cut_depth>
				o<wh-if1> endif
		
				o<oval_plunge> if [#<_plunge_down>]
					F#<_vertical_feed>
					G1 Z#<_cut_to:loop_end_z>
					#<_cut_to:seg_z> = #<_cut_to:loop_end_z>
					F#<_ffeed>
				o<oval_plunge> endif
			o<wh010-final> else
				#<final_loop> = 0
				F#<_final_feed>
				S#<_final_spindle_rpm>
			o<wh010-final> endif
		
			o<fv_cut-to> CALL [#<x2>] [#<y2>] [#<len_arc>] [#<dir>] [#<vx12>] [#<vy12>]
	  		o<fv_cut-to> CALL [#<x3>] [#<y3>] [#<len_cord>]
			o<fv_cut-to> CALL [#<x1>] [#<y1>] [#<len_arc>] [#<dir>] [#<vx31>] [#<vy31>]
		
			(Draw reference lines)			
			o<show_final_cut> if [#<final_loop> EQ 0]
				o<show_final_cut-1> if [#<_show_final_cuts> AND [#<show_final> EQ 11] AND #<_show_bottom_cut>] 
					G40
					G0 X#<x1> Y#<y1>
					#<show_final> = 8
				o<show_final_cut-1> elseif [#<_show_final_cuts> AND [#<show_final> EQ 11] OR [#<show_final> EQ 8]]
					#<_cut_to:seg_z> = #<cut_start>
					#<cut_depth> = #<cut_start>
					#<_cut_to:loop_end_z> = #<cut_start>
					G40
					G0 X#<x1> Y#<y1>
					G0 Z#<cut_start>				
					#<show_final> = 1
				o<show_final_cut-1> else
					#<show_final> = 0
				o<show_final_cut-1> endif	
			o<show_final_cut> endif		
		o<wh010> endwhile
	
	o<wh_cycle> endwhile
	
	G0 Z#<_z_clear>
	G40

o<fv_circle> endsub


(dot product for two vectors 1-2 and 3-2 having a common vertex 2)
(note u=[Ucos[a],Usin[a]], v=[V[cos[b],Vsin[b] then:)
(     u dot v = U*Vcos[a-b]    phi := a-b        )
(     u dot v > 0 ==> acute    phi  = [-90, 90]  )
(     u dot v < 0 ==> obtuse   phi  = [ 90,270]  )
(     u dot v = 0 ==> right    phi  = 90         )

(return:)
( _dot:dot scalar product)
(_dot:ang  [   0,180] angle between vectors -- for cw,ccw determination)
(_dot:phi  [-180,180] actual angle between vectors)
(_dot:acu  [   0, 90] acute angle between the extended vectors)

o<dot> sub
	(not_a_subfile)
	#<x1> = #1
	#<y1> = #2
	#<x2> = #3
	#<y2> = #4
	#<x3> = #5
	#<y3> = #6

	#<dx1> = [#<x1> - #<x2>]
	#<dy1> = [#<y1> - #<y2>]
	#<dx3> = [#<x3> - #<x2>]
	#<dy3> = [#<y3> - #<y2>]

	#<_dot:dot> = [#<dx1> * #<dx3> + #<dy1> * #<dy3>]
	#<magp>     = SQRT[[#<dx1> * #<dx1> + #<dy1> * #<dy1>] * [#<dx3> * #<dx3> + #<dy3> * #<dy3>]]
	#<_dot:ang> = ACOS[#<_dot:dot> / #<magp>]

	#<_dot:phi> = #<_dot:ang>
	o<dot0> if [#<_dot:dot> LT 0]
		#<_dot:phi> = [0 - #<_dot:ang>]
	o<dot0> endif

	#<_dot:acu> = #<_dot:phi>
	o<dot1> if [#<_dot:ang> GT 90]
		#<_dot:acu> = [180  - #<_dot:ang>]
	o<dot1> endif

	;(print,  dot: x1=#<x1> y1=#<y1> x2=#<x2> y2=#<y2> x3=#<x3> y3=#<y3> magp=#<magp> )
	;(print,  dot: dot=#<_dot:dot> ang=#<_dot:ang> phi=#<_dot:phi> acu=#<_dot:acu>)

o<dot> endsub




(fv_entry-angle used for calculating straight line entry in a corner and exit about same place without gouging)
o<fv_entry-angle> sub

	#<xprior> 	=  #1
	#<yprior> 	=  #2
	#<x1> 		=  #3
	#<y1> 		=  #4
	#<xto> 		=  #5
	#<yto> 		=  #6
	#<dir> 		=  #7 (2:cw, 3:ccw)
	#<opt> 		=  #8 (Inside=0:Outside=1:On the line=2:Create a pocket=3)
	#<cut_start> = #9

	G0 Z#<_z_clear>
	G40

	o<comp00> if [#<opt> EQ 2] (no compensation)
		G0 X#<x1> Y#<y1>
		#<_final:x> = #<x1>
		#<_final:y> = #<y1>
	o<comp00> else

		o<opt_00> if [#<opt> EQ 3] (pocket is inside)
			#<opt> = 0
		o<opt_00> endif	

		o<line> call [#<xto>] [#<yto>] [#<x1>] [#<y1>]
			#<cos12> = #<_line:cos>
			#<sin12> = #<_line:sin>
			#<phi12> = #<_line:phi>
				 
		(compute angles at line interesctions:)
		o<dot> call [#<xprior>] [#<yprior>] [#<x1>] [#<y1>] [#<xto>] [#<yto>]
			#<ang312> = #<_dot:ang>
				 
		#<tool_radius> = [[#5410 + .001] / 2]

		o<in_out> if [#<opt> EQ 0] (inside)
			#<elen12> = [#<tool_radius> / [TAN[#<ang312> / 2]]]
			#<k12>    = [#<elen12> / #<tool_radius>]
			#<ax>     = [#<x1> + #<elen12> * #<cos12>]
			#<ay>     = [#<y1> + #<elen12> * #<sin12>]
			 (compute pre-entry points:)
			o<dir00> if [#<dir> EQ 2]
				#<bx> = [#<ax> + #<tool_radius> * #<sin12> - #<tool_radius> * #<cos12>]
				#<by> = [#<ay> - #<tool_radius> * #<cos12> - #<tool_radius> * #<sin12>]
				#<cx> = [#<bx> + #<tool_radius> * #<cos12>]
				#<cy> = [#<by> + #<tool_radius> * #<sin12>]
				#<vx> = [        #<tool_radius> * #<cos12>]
				#<vy> = [        #<tool_radius> * #<sin12>]
			o<dir00> else (direction EQ 3 CCW)
				#<bx> = [#<ax> - #<tool_radius> * #<sin12> - #<tool_radius> * #<cos12>]
				#<by> = [#<ay> + #<tool_radius> * #<cos12> - #<tool_radius> * #<sin12>]
				#<cx> = [#<bx> + #<tool_radius> * #<cos12>]
				#<cy> = [#<by> + #<tool_radius> * #<sin12>]
				#<vx> = [        #<tool_radius> * #<cos12>]
				#<vy> = [        #<tool_radius> * #<sin12>]
			o<dir00> endif

			(rampdown finishes at point 2, to exit: need to turn corner at 2)
			(and go along the 2-->3 line enough to exit)
			(need a test here: if you go along 23 too far you gouge vertex 3)
			#<_final:x> = [#<x1> + #<elen12> * #<cos12>]
			#<_final:y> = [#<y1> + #<elen12> * #<sin12>]

			G0 X#<cx> Y#<cy> (preentry 1)
			G0 X#<bx> Y#<by> (preentry 2)
			
			o<dir10>  if [#<dir> EQ 2]
				G42 (cutter radius comp right of path)
				G2 X#<ax> Y#<ay> I#<vx> J#<vy> (arc entry)
			o<dir10>  else (direction EQ 3 CCW)
				G41 (cutter radius comp left of path)
				G3 X#<ax> Y#<ay> I#<vx> J#<vy> (arc entry)
			o<dir10>  endif

		o<in_out> else (outside)

			o<dir50>  if [#<dir> EQ 2]
				#<bx> = [#<x1> -  #<tool_radius> * sin[#<phi12>] - #<tool_radius> * cos[#<phi12>]]
				#<by> = [#<y1> +  #<tool_radius> * cos[#<phi12>] - #<tool_radius> * sin[#<phi12>]]
				#<vx> = [         #<tool_radius> * cos[#<phi12>]] (b to arc center)
				#<vy> = [         #<tool_radius> * sin[#<phi12>]]
				
				G0 X#<bx> Y#<by>
				G41 (cutter radius comp left of path)
				G3 X#<x1> Y#<y1> I#<vx> J#<vy> (arc entry)
				
			o<dir50>  else (dir EQ 3 CCW)
				#<bx> = [#<x1> +  #<tool_radius> * sin[#<phi12>] - #<tool_radius> * cos[#<phi12>]]
				#<by> = [#<y1> -  #<tool_radius> * cos[#<phi12>] - #<tool_radius> * sin[#<phi12>]]
				#<vx> = [         #<tool_radius> * cos[#<phi12>]] (b to arc center)
				#<vy> = [         #<tool_radius> * sin[#<phi12>]]
				
				G0 X#<bx> Y#<by>
				G42 (cutter radius comp right of path)
				G2 X#<x1> Y#<y1> I#<vx> J#<vy> (arc entry)
				
			o<dir50>  endif
			
			#<_final:x> = #<x1>
			#<_final:y> = #<y1>
		o<in_out>   endif
	o<comp00> endif
	
;	#<_final:x1> = #<x1>
;	#<_final:y1> = #<y1>

	G0 Z[#<cut_start> + 0.01] (hardcoded delta)
	G1 Z#<cut_start> (plunge)
	
o<fv_entry-angle> endsub



(creates a regular polygon)
o<fv_polygon> sub (CALL [#cx][#cy][#n][#radius][#rot][#opt][#dir][#<_surface>][#dpt][#fcut])
	#<cx>         =  #1
	#<cy>         =  #2
	#<edges>      =  #3
	#<final_rad>  =  ABS[#4]
	#<angle>      =  #5
	#<cut_opt>    =  #6 (Inside=0:Outside=1:On the line=2:Create a pocket=3)
	#<dir>	      =  #7 (Clockwise=2:Counter-Clockwise=3)
	#<cut_start>  =  #8
	#<cut_depth>  =  #9
	#<show_final> = #10

	(Check validity of params passed)

	o<l00-1> if [#<final_rad> EQ 0]
		(debug, Polygon: bad radius - EXITING)
		(print, Polygon: bad radius - EXITING)
		(AXIS,notify, Polygon: bad radius - EXITING)
		M2        
	o<l00-1> endif
	
	o<l02> if [#<cut_depth> EQ 0.0]
		(debug, circle: bad cut_depth #<cut_depth> - EXITING)
		(print, circle: bad cut_depth #<cut_depth> - EXITING)
		(AXIS,notify, circle: bad cut_depth - EXITING)
		M2
	o<l02> else if [#<cut_depth> GT 0.0]
		#<cut_depth> = [0 - #<cut_depth>]           
	o<l02> endif

	(end validity check)
	
	o<if-dir> if [#<dir> EQ 3]
		#<circ> = 360
	o<if-dir> else
		#<circ> = -360
	o<if-dir> endif
	
	#<ang> = [[180 - [360 / #<edges>]] / 2]
	#<h> = [#<final_rad> * SIN[#<ang>]]
	
	o<pocket> if [[#<cut_opt> EQ 3] AND [#5410 GT 0] AND [#<h> GT #5410]] (...a pocket and tool dia > 0)
		#<cycle_count> = FUP[#<h> / #5410 / #<_pocket_ratio>]
		#<min_rad> = [#<_pocket_ratio> * #5410 / SIN[#<ang>]]
	o<pocket> else
		#<cycle_count> = 1
		#<min_rad> = #<final_rad>
	o<pocket> endif
	
	#<cycle> = 0

	(expanding from mid to max size)
	o<wh_cycle> while [#<cycle> LT #<cycle_count>] 
		o<wh_cycle-0> if [#<cycle> EQ #<cycle_count> - 1]
			#<radius> = #<final_rad>
			#<t_h> = #<h>
		o<wh_cycle-0> else
			#<radius> = [#<min_rad> + [#<final_rad> - #<min_rad>] * #<cycle> / [#<cycle_count> - 1]]
			#<t_h> = [#<radius> / #<final_rad> *  #<h>]
		o<wh_cycle-0> endif	 
		
		#<cycle> = [#<cycle> + 1]
	
		(calc first and second points)
		o<rotate-xy> CALL [#<cx> + #<radius>] [#<cy>] [#<cx>] [#<cy>] [#<angle>]
			#<x1> = #<_rotate_result_x>
			#<y1> = #<_rotate_result_y>
		o<rotate-xy> CALL [#<cx> + #<radius>] [#<cy>] [#<cx>] [#<cy>] [#<angle> + #<circ> / #<edges>]
			#<x2> = #<_rotate_result_x>
			#<y2> = #<_rotate_result_y>
		o<rotate-xy> CALL [#<cx> + #<radius>] [#<cy>] [#<cx>] [#<cy>] [#<angle> - #<circ> / #<edges>]
			#<xlast> = #<_rotate_result_x>
			#<ylast> = #<_rotate_result_y>
	
		o<len_calc> if [#<cut_opt> EQ 1] (Outside)
			#<t_h> = [#<t_h> + #5410 / 2]
			#<len> = [[SIN[90 - #<ang>] * #<t_h> * 2 / SIN[#<ang>]]]
		o<len_calc> elseif [#<cut_opt> EQ 2] (On the line)
			#<len> = [#<radius> * COS[#<ang>] * 2]
		o<len_calc> else (Inside or pocket)
			#<t_h> = [#<t_h> - #5410 / 2]
			#<len> = [SIN[90 - #<ang>] * #<t_h> * 2 / SIN[#<ang>]]
		o<len_calc> endif		
		
		#<_cut_to:seg_z> = #<cut_start>

		#<final_loop> = 1
		#<final_loop_to_do> = 1
		o<will_show_final> if [#<cycle> EQ #<cycle_count>]
			/ #<show_final> = [#10 + 10]
		o<will_show_final> else
			#<show_final> = 0
		o<will_show_final> endif
	
		F#<_ffeed>
		S#<_spindle_rpm>
		
		o<fv_entry-angle> call [#<xlast>] [#<ylast>] [#<x1>] [#<y1>] [#<x2>] [#<y2>] [#<dir>] [#<cut_opt>] [#<cut_start>]

		(down to cut_depth)
		o<wh010> while [[#<_cut_to:seg_z> GT #<cut_depth>] OR #<final_loop> OR #<show_final>]
		
			o<wh010-final> if [#<_cut_to:seg_z> GT #<cut_depth>]
				#<_cut_to:loop_end_z> = [#<_cut_to:seg_z> + #<_depth_step>]
				o<wh-if1> if [#<_cut_to:loop_end_z> LT #<cut_depth>]
					#<_cut_to:loop_end_z> = #<cut_depth>
				o<wh-if1> endif
	
				o<oval_plunge> if [#<_plunge_down>]
					F#<_vertical_feed>
					G1 Z#<_cut_to:loop_end_z>
					#<_cut_to:seg_z> = #<_cut_to:loop_end_z>
					F#<_ffeed>
				o<oval_plunge> endif
			o<wh010-final> else
				#<final_loop> = 0
				o<final_seg> if [#<final_loop_to_do>]
					#<final_loop_to_do> = -1
				o<final_seg> endif
				F#<_final_feed>
				S#<_final_spindle_rpm>
			o<wh010-final> endif
		
			#<rot> = #<angle>
			o<polygon-cycle-g> repeat [#<edges>]
				#<rot> = [#<rot> + #<circ> / #<edges>]
				o<rotate-xy> CALL [#<cx> + #<radius>] [#<cy>] [#<cx>] [#<cy>] [#<rot>]
				o<fv_cut-to> CALL [#<_rotate_result_x>] [#<_rotate_result_y>] [#<len>] [0]
			o<polygon-cycle-g> endrepeat
			o<final_seg-0> if [#<final_loop_to_do> EQ -1]
				#<final_loop_to_do> = 0
				o<fv_cut-to> CALL [#<_final:x>] [#<_final:y>] [#5410 / 2] [1]
			o<final_seg-0> endif
		
			(Draw reference lines)			
			o<show_final_cut> if [#<final_loop> EQ 0]
				o<show_final_cut-1> if [#<_show_final_cuts> AND [#<show_final> EQ 11] AND #<_show_bottom_cut>] 
					G40
					G0 X#<x1> Y#<y1>
					#<show_final> = 8
				o<show_final_cut-1> elseif [#<_show_final_cuts> AND [#<show_final> EQ 11] OR [#<show_final> EQ 8]]
					#<_cut_to:seg_z> = #<cut_start>
					#<cut_depth> = #<cut_start>
					#<_cut_to:loop_end_z> = #<cut_start>
					G40
					G0 X#<x1> Y#<y1>
					G0 Z#<cut_start>				
					#<show_final> = 1
				o<show_final_cut-1> else
					#<show_final> = 0
				o<show_final_cut-1> endif	
			o<show_final_cut> endif			
		o<wh010> endwhile (down)
	o<wh_cycle> endwhile (expand)
	
	G0 Z#<_z_clear>
	G40	
		
o<fv_polygon> endsub

(End definitions)

o<task-001-enabled> if [1]
	#<_surface> = 0.000
	#<_depth> = -0.500
	#<_z_clear> = 0.200
	#<_show_final_cuts> = 1


/	o<cube-001> if [1]
/		o<fv_design-cube> CALL [0.000] [0.000] [0.000] [1] [#<_units_w> * 4.000] [#<_units_w> * 2.000] [#<_units_w> * #<_depth>]
/	o<cube-001> endif


(Tool change)
o<toolchng-001-ena> if [1]
	M9
	T4 M6 G43
	#<_tool_dia> = #5410
	#<_tool_d> = #5410

	o<toolchng-001-if> if [#<_tool_probe_set>]
		o<set-tool-length> CALL
	o<toolchng-001-if> endif

	o<toolchng-001-act> if [0 EQ 0]
		M0
	o<toolchng-001-act> elseif [0 EQ 1]
		G4 P5
		M3
	o<toolchng-001-act> else (will auto-restart)
		M3
	o<toolchng-001-act> endif

	M9
o<toolchng-001-ena> endif

S1000
F5.000

#<_final_feed> = 5.000
#<_final_spindle_rpm> = 1000
#<_ffeed> = 5.000
#<_vertical_feed> = 1.000
#<_plunge_down> = 0
#<_depth_step> = -0.100
#<_plunge_ratio> = 0.07
#<_pocket_ratio> = 0.80
(End tool change)
	o<swap_units-002-ifB> if [1]
		o<swap_units-002-ifB0> if [#<_imperial> EQ 1]
			#<_units_factor> = [1.0 / 25.4]
			o<swap_units-002-ifB1> if [1]
				#<_units_r> = [1.0 / 25.4]
			o<swap_units-002-ifB1> endif
			o<swap_units-002-ifB2> if [1]
				#<_units_w> = [1.0 / 25.4]
			o<swap_units-002-ifB2> endif
			o<swap_units-002-ifB3> if [0]
				#<_units_d> = [1.0 / 25.4]
			o<swap_units-002-ifB3> endif
		o<swap_units-002-ifB0> else
			#<_units_factor> = 25.4
			o<swap_units-002-ifC1> if [1]
				#<_units_r> = 25.4
			o<swap_units-002-ifC1> endif
			o<swap_units-002-ifC2> if [1]
				#<_units_w> = 25.4
			o<swap_units-002-ifC2> endif
			o<swap_units-002-ifC3> if [0]
				#<_units_d> = 25.4
			o<swap_units-002-ifC3> endif
		o<swap_units-002-ifB0> endif
	o<swap_units-002-ifB> endif

	(Items with swapped units...)


	o<circle-001> if [1]
		o<fv_circle> CALL [0.000][0.000][25.000*#<_units_r>][0.000*#<_units_r>] [0.00] [0] [2] [#<_surface>] [#<_depth>*#<_units_d>] [1]
	o<circle-001> endif



	(End items)

	(Restoring units)
	o<swap_units-002-ifA> if [1]
		#<_units_factor> = 1.0
		#<_units_r> = 1.0
		#<_units_w> = 1.0
		#<_units_d> = 1.0
	o<swap_units-002-ifA> endif


	o<polygon-001> if [1]
		o<fv_polygon> CALL [0.000] [0.000] [6] [1.000*#<_units_r>] [0.00] [0] [2][#<_surface>] [#<_depth>*#<_units_d>] [1]
	o<polygon-001> endif



	G0 Z[1.5]
	G0 X[#<_x>] Y[#<_y>]
o<task-001-enabled> endif

M2